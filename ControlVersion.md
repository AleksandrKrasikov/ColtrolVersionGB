# Введение в контроль версий.

*Контроль версий (контроль исходного кода)* — практика, которая позволяет отслеживать изменения исходного кода и управлять ими.

Контроль версий необходим, чтобы:

* хранить разные версии проекта;
* возвращаться к разным версиям проекта.

Хранение версий сводится к созданию копий информации на компьютере или сервере.

Функцию возврата реализуют за счёт восстановления предыдущих версий.

**Cистема контроля** — это реализованная возможность замены информации с использованием сохраненных версий.

>*Когда вы работаете в команде, контроль версий помогает синхронизировать усилия.*

**Примеры использования контроля версий в жизни:**
* Сохранение в компьютерных играх.
    >Если вы сделали что-то неправильно, вы всегда можете вернуться к состоянию,когда вас всё устраивало.
* Группа сотрудников пишет текст в течение нескольких дней.
    >Когда готов первый черновик, его отправляют на ревью коллеге. Пока он читает, другие сотрудники продолжают работу над текстом. И когда ревьюер «выкатывает» комментарии к первой версии черновика, у команды уже появился «Черновик 2». После внесения правок появляется ещё и «Черновик 3». Файлы множатся и работа усложняется. 
    
    ![Пример Контроля Версий](ControlVersion.jpg)

    >Чтобы избежать описанной выше ситуации, команда обычно принимает правила именования и сортировки файлов. Но этого недостаточно для комфортной работы: всё равно приходится контролировать, когда пришёл документ, кто его владелец, каким образом документ был создан.Можно организовать совместную работу с помощью сервиса Google Docs, но в реальных бизнес-ситуациях это не всегда удобно: чтобы контролировать изменения документа, его приходится править и перечитывать. А ещё работа в облачных сервисах — это угроза безопасности.

## Git - программа для контроля версий.

Программа Git берёт на себя контроль версий проекта и позволяет переключаться между ними. Обратите внимание:
 >Git хранит **не файлы целиком, а отличия между ними**. Это позволяет 
экономить память. Автор программы — **Линус Торвальдс**, создатель ОС Linux. 

![Пример работы Git](Git.jpg)

## Команды Git

Все команды задаём при помощи написания кода в терминале.
С командами Git можно прознакомиться в файле, расположенном в этом репозитории 

[InstructionGit.md]

> Git отслеживает файлы по имени!
Если изменить имя файла, необходимо добавить файл с новый именем + git commit.

Работать с Git можно двумя способами:

    * Через командную строку (терминал).
    * Через IDE.
## Работа с ветками (branch) в Git.
    
Ветки позволяют легко управлять черновиками и чистовиками в Git.

Работу с ветками начинаем с запуска Git в репозитории.
* Вводим git init и git status, чтобы убедиться, что репозиторий создан.
* Повторяем команды git add, git log, git status.

## Работа с черновиками.

### git branch
Если у нас несколько версий черновика, мы можем вывести на экран ветку, где находимся, командой **git branch**.
Создать ветку можно командой **git branch**. Делать это надо в папке с репозиторием.

Чаще всего у нас будет ветка master с черновиком и отдельная ветка — с чистовиком. 
Если потребуется переключиться с одной ветки на другую, вызовем команду 
**git checkout NameOfBranch**

Команда **git log** покажет состояние более новых версий проекта. Но если вызвать эту команду из самой «свежей» ветки, мы не увидим исходного файла.

Когда мы правим текст/код в текущей ветке, автоматического слияния не происходит: можно создавать один документ в разных версиях в разных ветках.

Если черновики нас полностью устраивают и нам нужно внести изменения, чтобы 
информация появилась в чистовике. Для этого есть команда **git merge**.

После всех изменений дерево версий принимает следующий вид:
![Дерево версий](GitTree.jpg)

## Удаление веток.

Если ветка с черновиком больше не нужна, ее можно удалить с помощью команды 
**git branch -d NameOfBranch**.
____________


В Git не принято добавлять файлы изображений, их хранят на сторонних 
носителях. Чтобы исключить ненужные файлы из загрузки, есть команда **git ignore**.

## Конфликт изменений

При работе в двух ветках одновременно может возникнуть ситуация, когда в одной и другой ветке мы по-разному изменили блок текста. Если затем мы попробуем слить эти ветки, Git сообщит о конфликте и предложит выбрать, какие же изменения записать.

![Конфликт слияния веток](Conflict.jpg)

Поэтому у проекта в репозитории должен быть один ответственный пользователь, наделённый правом проводить слияния и разрешать конфликты.

## GitHub.

При запуске команды git init всё происходит только в локальном репозитории: в папке на компьютере пользователя, эту папку создавшего. Но для работы в команде программисты используют удаленные репозитории.

## Работа с удаленными репозиториями. Скачивание из текущего репозитория и слияние со своей версией.

Копировать внешний репозиторий на свой ПК можно командой **git clone**.

Команда **git clone** составная: она не только загружает все изменения, но и пытается слить все ветки на локальном компьютере и в удаленном репозитории.

* __git pull__ - позволяет скачать все из текущего репозитория и автоматически 
сделать merge (слияние) с нашей версией.

* __git push__ - позволяет отправить свою версию репозитория во внешний репозиторий. При первом её использовании нужна авторизация.
![Git push](GitPush.jpg)

* __pull request__ - позволяет отправить предложения изменений, а также запрос на вливание изменений в репозиторий.

В компаниях один ответственный за проект создает аккаунт. Другие пользователи дают команду pull request. Предлагать изменения на GitHub нужно в отдельной ветке. Сначала пользователь копирует репозиторий на свой компьютер, делает fork репозитория, затем клонирует версию на своём ПК, создаёт ветку с предлагаемыми изменениями, отправляет изменения командой push в свой аккаунт на GitHub и даёт команду pull request. 

### Как сделать **pull request**:
* Делаем   (ответвление) репозитория **fork**;
* Делаем **git clone**   версии репозитория СВОЕЙ;
* Создаем новую ветку и в НЕЕ вносим свои изменения;
* Фиксируем изменения (делаем коммиты);
* Отправляем свою версию в свой GitHub;
* На сайте **GitHub** нажимаем кнопку **pull reques**.